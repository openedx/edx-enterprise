diff --git a/enterprise/tpa_pipeline.py b/enterprise/tpa_pipeline.py
new file mode 100644
--- /dev/null
+++ b/enterprise/tpa_pipeline.py
@@ -0,0 +1,67 @@
+"""
+Enterprise pipeline steps for third-party auth (SAML/OAuth).
+"""
+import logging
+
+from django.contrib.auth import get_user_model
+
+from enterprise.models import EnterpriseCustomerIdentityProvider, EnterpriseCustomerUser
+
+User = get_user_model()
+log = logging.getLogger(__name__)
+
+
+def enterprise_associate_by_email(strategy, details, user=None, *args, **kwargs):
+    """
+    SAML pipeline step: associate the auth user with an existing user by email when
+    the existing user is an enterprise customer user for the current provider.
+
+    This step replaces the platform-side ``associate_by_email_if_enterprise_user`` function.
+    It is registered in ``SOCIAL_AUTH_PIPELINE`` via ``enterprise/settings/common.py`` (epic 18).
+    """
+    if user:
+        return None
+
+    email = details.get('email')
+    if not email:
+        return None
+
+    try:
+        existing_user = User.objects.get(email=email)
+    except User.DoesNotExist:
+        return None
+
+    try:
+        current_provider = strategy.request.backend
+        provider_id = getattr(current_provider, 'provider_id', None)
+    except AttributeError:
+        return None

+    if not provider_id:
+        return None

+    enterprise_customer_idps = EnterpriseCustomerIdentityProvider.objects.filter(
+        provider_id=provider_id
+    )
+    for idp in enterprise_customer_idps:
+        if EnterpriseCustomerUser.objects.filter(
+            enterprise_customer=idp.enterprise_customer,
+            user_id=existing_user.id,
+        ).exists():
+            log.info(
+                "Associating enterprise user %s via provider %s by email match.",
+                existing_user.id,
+                provider_id,
+            )
+            return {'user': existing_user}
+
+    return None
diff --git a/enterprise/platform_signal_handlers.py b/enterprise/platform_signal_handlers.py
--- a/enterprise/platform_signal_handlers.py
+++ b/enterprise/platform_signal_handlers.py
@@ -1,5 +1,6 @@
 """
 Signal handlers for platform-emitted Django signals consumed by edx-enterprise.
 """
 import logging
+
 from consent.models import DataSharingConsent
@@ -56,3 +57,22 @@ def handle_user_retirement(sender, user, retired_username, retired_email, **kwa
     log.info(
         "Retired %d PendingEnterpriseCustomerUser record(s) for user %s",
         pending_count,
         user.id,
     )
+
+
+def handle_social_auth_disconnect(sender, request, user, social, **kwargs):  # pylint: disable=unused-argument
+    """
+    Handle SocialAuthAccountDisconnected signal to unlink enterprise user from IdP.
+
+    Arguments:
+        sender: the class that sent the signal (unused).
+        request: the HTTP request during which the disconnect occurred.
+        user: the Django User disconnecting the social auth account.
+        social: the social auth backend instance.
+        **kwargs: forward-compatible catch-all.
+    """
+    # Deferred import â€” will be replaced with internal path in epic 17.
+    from openedx.features.enterprise_support.api import unlink_enterprise_user_from_idp
+    if request:
+        unlink_enterprise_user_from_idp(request)
diff --git a/enterprise/apps.py b/enterprise/apps.py
--- a/enterprise/apps.py
+++ b/enterprise/apps.py
@@ -50,6 +50,13 @@ class EnterpriseConfig(AppConfig):
         try:
             from openedx.core.djangoapps.user_api.accounts.signals import USER_RETIRE_LMS_CRITICAL
             USER_RETIRE_LMS_CRITICAL.connect(handle_user_retirement)
         except ImportError:
             pass
+
+        from enterprise.platform_signal_handlers import handle_social_auth_disconnect  # pylint: disable=import-outside-toplevel
+        try:
+            from common.djangoapps.third_party_auth.signals import SocialAuthAccountDisconnected
+            SocialAuthAccountDisconnected.connect(handle_social_auth_disconnect)
+        except ImportError:
+            pass
